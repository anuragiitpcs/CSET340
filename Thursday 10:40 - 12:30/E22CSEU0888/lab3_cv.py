# -*- coding: utf-8 -*-
"""LAB3_CV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M113iHSiMk3w5CI3t7Ro_XG20ImXsxSV
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu
from skimage.segmentation import watershed
from skimage.segmentation import clear_border
from skimage.measure import label
from skimage.feature import canny
from skimage.color import rgb2gray
from google.colab.patches import cv2_imshow

def task_1(image_path):
    # Read the image
    image = cv2.imread(image_path)

    # Display the original image
    cv2_imshow(image)

    # Extract image size
    height, width, channels = image.shape
    print(f"Image Size: {width}x{height}, Channels: {channels}")

    # Calculate total pixels
    total_pixels = height * width
    print(f"Total Pixels: {total_pixels}")

    # Convert BGR to RGB
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    print("RGB Image")
    cv2_imshow(image_rgb)

    # Convert RGB to Grayscale
    gray_image = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
    print("Grayscale Image")
    cv2.imwrite('gray_image.jpg', gray_image)
    cv2_imshow(gray_image)

    # Convert Grayscale to Binary using Otsuâ€™s Thresholding
    thresh_val, binary_image = cv2.threshold(gray_image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    print("Binary Image")
    cv2_imshow(binary_image)

    # Count the number of black pixels
    black_pixel_count = np.sum(binary_image == 0)
    print(f"Black Pixels Count: {black_pixel_count}")

task_1('test.png')

from skimage.filters import sobel, prewitt, roberts

def task_2(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    sobel_edges = sobel(image)
    prewitt_edges = prewitt(image)
    roberts_edges = roberts(image)
    canny_edges = cv2.Canny(image, 100, 200)

    cv2.imwrite('sobel.jpg', (sobel_edges * 255).astype(np.uint8))
    cv2.imwrite('prewitt.jpg', (prewitt_edges * 255).astype(np.uint8))
    cv2.imwrite('roberts.jpg', (roberts_edges * 255).astype(np.uint8))
    cv2.imwrite('canny.jpg', canny_edges)

    _, global_thresh = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)
    adaptive_thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

    gray = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2GRAY)
    ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    kernel = np.ones((3,3), np.uint8)
    sure_bg = cv2.dilate(thresh, kernel, iterations=3)
    dist_transform = cv2.distanceTransform(thresh, cv2.DIST_L2, 5)
    _, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)
    sure_fg = np.uint8(sure_fg)
    unknown = cv2.subtract(sure_bg, sure_fg)
    markers = cv2.connectedComponents(sure_fg)[1]
    markers += 1
    markers[unknown == 255] = 0
    watershed_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
    cv2.watershed(watershed_image, markers)
    watershed_image[markers == -1] = [0, 0, 255]

    cv2.imwrite('global_threshold.jpg', global_thresh)
    cv2.imwrite('adaptive_threshold.jpg', adaptive_thresh)
    cv2.imwrite('watershed.jpg', watershed_image)

task_2('gray_image.jpg')